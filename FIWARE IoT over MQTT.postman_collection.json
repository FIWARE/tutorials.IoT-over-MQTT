{
	"info": {
		"_postman_id": "fddcfd01-0c04-4da3-bc34-2ad6ff9fbf0e",
		"name": "FIWARE IoT over MQTT",
		"description": "This tutorial uses introduces the use of the MQTT protocol across IoT devices connecting to FIWARE. The [UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/usermanual/index.html#user-programmers-manual) IoT Agent\ncreated in the [previous tutorial](https://github.com/Fiware/tutorials.IoT-Agent) is reconfigured to\ncommunicate with a set of dummy IoT devices using MQTT\n\n# What is MQTT?\n\nMQTT is publish-subscribe-based messaging protocol used in the Internet of Things. It works on top of the TCP/IP\nprotocol, and is designed for connections with remote locations where a \"small code footprint\" is required or the\nnetwork bandwidth is limited. The goal is to provide a protocol, which is bandwidth-efficient and uses little\nbattery power.\n\nThe [previous tutorial](https://github.com/Fiware/tutorials.IoT-Agent) used HTTP as its transport mechanism between\nthe devices and the IoT Agent. HTTP uses a request/response paradigm where each device connects directly to the IoT Agent.\nMQTT is different in that publish-subscribe is event-driven and pushes messages to clients. It requires an additional\ncentral communication point (known as the MQTT broker) which it is in charge of dispatching all messages between the senders and the rightful receivers. Each client that publishes a message to the broker, includes a **topic** into the message. The **topic** is the routing information for the broker. Each client that wants to receive messages subscribes to a certain **topic** and the broker delivers all messages with the matching **topic** to the client. Therefore the clients don’t have to know each other, they only communicate over the **topic**. This architecture enables highly scalable solutions without dependencies between the data producers and the data consumers.\n\n\nThe UltraLight 2.0 IoT Agent will only send or interpret messages using the [UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/usermanual/index.html#user-programmers-manual) syntax,\nhowever it can be used to send and receive messages over multiple **transport** mechanisms. Therefore we\nare able to use the same FIWARE generic enabler to connect to a wider range of IoT devices.\n\n#### Mosquitto MQTT Broker\n\n[Mosquitto](https://mosquitto.org/) is a readily available, open source MQTT broker which will be used during this tutorial.\nIt is available licensed under EPL/EDL. More information can be found at https://mosquitto.org/\n\n\n#### Device Monitor\n\nFor the purpose of this tutorial, a series of dummy IoT devices have been created, which will be attached to the context broker. Details of the architecture and protocol used can be found in the [IoT Sensors tutorial](https://github.com/Fiware/tutorials.IoT-Sensors)\nThe state of each device can be seen on the UltraLight device monitor web-page found at: `http://localhost:3000/device/monitor`\n\n![FIWARE Monitor](https://fiware.github.io/tutorials.IoT-over-MQTT/img/device-monitor.png)\n\n# Architecture\n\nThis application builds on the components created in [previous tutorials](https://github.com/Fiware/tutorials.IoT-Agent/). It\nwill make use of two FIWARE components - the [Orion Context Broker](https://fiware-orion.readthedocs.io/en/latest/) and the [IoT Agent for UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/). Usage of the Orion Context Broker is sufficient for an application to qualify as *“Powered by FIWARE”*.\nBoth the Orion Context Broker and the IoT Agent rely on open source [MongoDB](https://www.mongodb.com/) technology to keep persistence of the information they hold. We will also be using the dummy IoT devices created in the [previous tutorial](https://github.com/Fiware/tutorials.IoT-Agent/) \nAdditionally will add an instance of the [Mosquitto](https://mosquitto.org/) MQTT broker which is open source and available under the EPL/EDL.\n\n\nTherefore the overall architecture will consist of the following elements:\n\n* The FIWARE [Orion Context Broker](https://fiware-orion.readthedocs.io/en/latest/) which will receive requests using [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2)\n* The FIWARE [IoT Agent for UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/) which will:\n + receive southbound requests using [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2) and convert them to  [UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/usermanual/index.html#user-programmers-manual) MQTT topics for the MQTT Broker\n + listen to the **MQTT Broker** on registered topics to send measurements northbound\n* The [Mosquitto](https://mosquitto.org/) **MQTT Broker** which acts as a central communication point, passing \n  MQTT topics between the **IoT Agent** and IoT devices as necessary.\n* The underlying [MongoDB](https://www.mongodb.com/) database :\n  + Used by the **Orion Context Broker** to hold context data information such as data entities, subscriptions and registrations\n  + Used by the **IoT Agent** to hold device information such as device URLs and Keys\n* A webserver acting as set of [dummy IoT devices](https://github.com/Fiware/tutorials.IoT-Sensors) using the [UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/usermanual/index.html#user-programmers-manual) protocol running over MQTT.\n* The **Context Provider NGSI** proxy is not used in this tutorial. It does the following:\n  + receive requests using [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2)\n  + makes requests to publicly available data sources using their own APIs in a proprietary format \n  + returns context data back to the Orion Context Broker in [NGSI](https://fiware.github.io/specifications/OpenAPI/ngsiv2) format.\n* The **Stock Management Frontend**  is not used in this tutorial will it does the following:\n  + Display store information\n  + Show which products can be bought at each store\n  + Allow users to \"buy\" products and reduce the stock count.\n\n\nSince all interactions between the elements are initiated by HTTP or MQTT requests over TCP, the entities can be containerized and run from exposed ports. \n\n![](https://fiware.github.io/tutorials.IoT-over-MQTT/img/architecture.png)\n\nThe necessary configuration information for wiring up the Mosquitto MQTT Broker, the IoT devices and the IoT Agent can be seen in the services section of the associated `docker-compose.yml`  file:\n\n## Mosquitto Configuration\n\n```yaml\n  mosquitto:\n    image: eclipse-mosquitto\n    hostname: mosquitto\n    container_name: mosquitto\n    networks:\n        - default\n    expose:\n        - \"1883\"\n        - \"9001\"\n    ports:\n        - \"1883:1883\"\n        - \"9001:9001\"\n    volumes:\n      - ./mosquitto/mosquitto.conf:/mosquitto/config/mosquitto.conf\n    \n```\n\nThe `mosquitto` container is listening on two ports: \n\n* Port `3000` is exposed so we can post MQTT topics\n* Port `9001` is the standard port for HTTP/Websocket communications\n\nThe attached volume is a [configuration file](https://github.com/Fiware/tutorials.IoT-over-MQTT/blob/master/osquitto/mosquitto.conf) used to increase the debug level of the MQTT Message Broker.\n\n## Dummy IoT Devices Configuration\n\n```yaml\n  context-provider:\n    image: quay.io/fiware/cp-web-app:latest\n    hostname: context-provider\n    container_name: context-provider\n    networks:\n        - default\n    expose:\n        - \"3000\"\n        - \"3001\"\n    ports:\n        - \"3000:3000\"\n        - \"3001:3001\"\n    environment:\n        - \"DEBUG=proxy:*\"\n        - \"PORT=3000\"\n        - \"DUMMY_DEVICES_PORT=3001\"\n        - \"DUMMY_DEVICES_API_KEY=4jggokgpepnvsb2uv4s40d59ov\"\n        - \"DUMMY_DEVICES_TRANSPORT=MQTT\"\n```\n\nThe `context-provider` container is listening on two ports: \n\n* Port `3000` is exposed so we can see the web-page displaying the Dummy IoT devices.\n* Port `3001` is exposed purely for tutorial access - so that cUrl or Postman can make UltraLight commands\n  without being part of the same network.\n\n\nThe `context-provider` container is driven by environment variables as shown:\n\n| Key |Value|Description|\n|-----|-----|-----------|\n|DEBUG|`proxy:*`| Debug flag used for logging |\n|PORT|`3000`|Port used by web-app which displays the dummy device data |\n|DUMMY_DEVICES_PORT|`3001`|Port used by the dummy IoT devices to receive commands |\n|DUMMY_DEVICES_API_KEY|`4jggokgpepnvsb2uv4s40d59ov`| Random security key used for UltraLight interactions - used to ensure the integrity of interactions between the devices and the IoT Agent |\n\nThe other `context-provider` container configuration values described in the YAML file are not used in this tutorial.\n\n## IoT Agent for UltraLight 2.0 Configuration\n\nThe [IoT Agent for UltraLight 2.0](http://fiware-iotagent-ul.readthedocs.io/en/latest/)  can be instantiated within a Docker container. An official Docker image is available from [Docker Hub](https://hub.docker.com/r/fiware/iotagent-ul/) tagged `fiware/iotagent-ul`. The \nnecessary configuration can be seen below:\n\n```yaml\n  iot-agent:\n    image: quay.io/fiware/iotagent-ul:latest\n    hostname: iot-agent\n    container_name: fiware-iot-agent\n    depends_on:\n      - mongo-db\n    networks:\n        - default\n    expose:\n        - \"4041\"\n        - \"7896\"\n    ports:\n        - \"4041:4041\"\n        - \"7896:7896\"\n    environment:\n        - \"IOTA_CB_HOST=orion\"\n        - \"IOTA_CB_PORT=1026\"\n        - \"IOTA_NORTH_PORT=4041\"\n        - \"IOTA_REGISTRY_TYPE=mongodb\"\n        - \"IOTA_LOG_LEVEL=DEBUG\"\n        - \"IOTA_TIMESTAMP=true\"\n        - \"IOTA_MONGO_HOST=mongo-db\"\n        - \"IOTA_MONGO_PORT=27017\"\n        - \"IOTA_MONGO_DB=iotagentul\"\n        - \"IOTA_PROVIDER_URL=http://iot-agent:4041\"\n        - \"IOTA_MQTT_HOST=mosquitto\"\n        - \"IOTA_MQTT_PORT=1883\"\n```\n\nThe `iot-agent` container relies on the precence of the Orion Context Broker and uses a MongoDB database to hold device information such as device URLs and Keys. The container is listening on two ports: \n\n* Port `7896` is exposed to receive Ultralight measurements over HTTP from the Dummy IoT devices\n* Port `4041` is exposed purely for tutorial access - so that cUrl or Postman can make provisioning commands\n  without being part of the same network.\n\n\nThe `iot-agent` container is driven by environment variables as shown:\n\n| Key |Value|Description|\n|-----|-----|-----------|\n|IOTA_CB_HOST|`orion`| Hostname of the context broker to update context |\n|IOTA_CB_PORT|`1026`| Port that context broker listens on to update context |\n|IOTA_NORTH_PORT|`4041` | Port used for Configuring the IoT Agent and receiving context updates from the context broker |\n|IOTA_REGISTRY_TYPE|`mongodb`| Whether to hold IoT device info in memory or in a database |\n|IOTA_LOG_LEVEL|`DEBUG`|The log level of the IoT Agent |\n|IOTA_TIMESTAMP|`true`| Whether to supply timestamp information with each measurement received from attached devices |\n|IOTA_MONGO_HOST|`context-db`| The host name of mongoDB - used for holding device information |\n|IOTA_MONGO_PORT|`27017`| The port mongoDB is listening on |\n|IOTA_MONGO_DB|`iotagentul`| The name of the database used in mongoDB |\n|IOTA_PROVIDER_URL|`http://iot-agent:4041`| URL passed to the Context Broker when commands are registered, used as a forwarding URL location when the Context Broker issues a command to a device | \n|IOTA_MQTT_HOST|`mosquitto`| The host name of the MQTT Broker  |\n|IOTA_MQTT_PORT|`1883`| The port the MQTT Broker is listening on to receive topics |\n\nAs you can see, use of the MQTT transport is driven by only two environment variables `IOTA_MQTT_HOST` and `IOTA_MQTT_PORT`\n\n# Prerequisites\n\n## Docker and Docker Compose \n\nTo keep things simple all components will be run using [Docker](https://www.docker.com). **Docker** is a container technology which allows to different components isolated into their respective environments. \n\n* To install Docker on Windows follow the instructions [here](https://docs.docker.com/docker-for-windows/)\n* To install Docker on Mac follow the instructions [here](https://docs.docker.com/docker-for-mac/)\n* To install Docker on Linux follow the instructions [here](https://docs.docker.com/install/)\n\n**Docker Compose** is a tool for defining and running multi-container Docker applications. A \n[YAML file](https://raw.githubusercontent.com/Fiware/tutorials.IoT-over-MQTT/master/docker-compose.yml) is used\nconfigure the required services for the application. This means all container services can be brought up in a single \ncommand. Docker Compose is installed by default  as part of Docker for Windows and  Docker for Mac, however Linux users \nwill need to follow the instructions found  [here](https://docs.docker.com/compose/install/)\n## Cygwin for Windows\n\nWe will start up our services using a simple Bash script. Windows users should download [cygwin](http://www.cygwin.com/) to provide a command line functionality similar to a Linux distribution on Windows.\n\n\n# Start Up\n\nBefore you start you should ensure that you have obtained or built the necessary Docker images locally. Please clone the repository and create the necessary images by running the commands as shown:\n\n```console\ngit clone git@github.com:Fiware/tutorials.IoT-over-MQTT.git\ncd tutorials.IoT-over-MQTT\n\n./services create\n``` \n\n>**Note** The `context-provider` image has not yet been pushed to Docker hub.\n> Failing to build the Docker sources before proceeding will result in the following error:\n>\n>```\n>Pulling context-provider (fiware/cp-web-app:latest)...\n>ERROR: The image for the service you're trying to recreate has been removed.\n>```\n\n\nThereafter, all services can be initialized from the command line by running the [services](https://github.com/Fiware/tutorials.IoT-over-MQTT/blob/master/services) Bash script provided within the repository:\n\n```console\n./services start\n``` \n\n>:information_source: **Note:** If you want to clean up and start over again you can do so with the following command:\n>\n>```console\n>./services stop\n>``` \n>\n\n\n\n",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "513743"
	},
	"item": [
		{
			"name": "Checking Mosquitto Health",
			"item": [],
			"description": "We will start by mimicking the roles of both the IoT Agent and a dummy IoT device and send and receive some messages\nusing MQTT. This section of the tutorial requires several open terminals.\n\n### Start an MQTT Subscriber (1st Terminal)\n\nEventually once we have wired by the system correctly, IoT Agent will subscribe to all relevent events to listen for\nnorthbound traffic in the form of sensor measurements. It therefore will need to make a subscription\nacross all topics. Similarly an accuator must subscribe to a single topic to receive events which effect itself when \ncommands are sent southbound. To check that the lines of communication are open, we can subscribe to a given topic,\nand see that we are able to receive something when a message is published.\n\nOpen a **new terminal**, and create a new running `mqtt-subscriber` Docker container as follows:\n\n```console\ndocker run -it --rm --name mqtt-subscriber \\\n  --network fiware_default efrecon/mqtt-client sub -h mosquitto -t \"#\"\n```\n\nThe terminal will then be ready to receive events\n\n### Start an MQTT Publisher (2nd Terminal)\n\nA sensor sending northbound measurements will publish to those measurements to the MQTT Broker to be passed on to \nany subscriber than  wants them. The sensor will not need to make a connection to the subscriber directly. \n\nOpen a **new terminal**, and run a  `mqtt-publisher` Docker container to send a message as follows:\n\n```console\ndocker run -it --rm -name mqtt-publisher \\\n  --network fiware_default efrecon/mqtt-client pub -h mosquitto -m \"HELLO WORLD\" -t \"test\"\n```\n\n#### 1st terminal - Result:\n\nIf the MQTT Broker is functioning correctly, the message should be received in the other terminal\n\n```\nHELLO WORLD\n```\n\n\n### Stop an MQTT Subscriber (1st Terminal)\n\nTo terminate the MQTT subscriber, run the following Docker command:\n\n```console\ndocker stop mqtt-subscriber\n```\n\n### Show Mosquitto Log\n\nTo show that the communication occurred via the **MQTT Broker**, we can inspect the log of the `mosquitto` Docker container as shown:\n\n```console\ndocker logs --tail 10 mosquitto\n```\n\n#### Result:\n\n```\n1529661883: New client connected from 172.18.0.5 as mqttjs_8761e518 (c1, k0).\n1529662472: New connection from 172.18.0.7 on port 1883.\n1529662472: New client connected from 172.18.0.7 as mosqpub|1-5637527c63c1 (c1, k60).\n1529662472: Client mosqpub|1-5637527c63c1 disconnected.\n1529662614: New connection from 172.18.0.7 on port 1883.\n1529662614: New client connected from 172.18.0.7 as mosqsub|1-64b27d675f58 (c1, k60).\n1529662623: New connection from 172.18.0.8 on port 1883.\n1529662623: New client connected from 172.18.0.8 as mosqpub|1-ef03e74b0270 (c1, k60).\n1529662623: Client mosqpub|1-ef03e74b0270 disconnected.\n1529667841: Socket error on client mosqsub|1-64b27d675f58, disconnecting.\n```\n",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Connecting IoT Devices",
			"item": [
				{
					"name": "IoT Agent - Obtain Version Information",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "http://{{iot-agent}}/iot/about",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"about"
							]
						},
						"description": "Once the IoT Agent is running, You can check the status by making an HTTP request to the exposed port. \nIf the response is blank, this is usually because the MongoDB database holding the context information is not running or not connected.\n\n>**Troubleshooting:** What if the response is blank ?\n>\n> * To check that a docker container is running try\n>\n>```bash\n>docker ps\n>```\n>\n>You should see several containers running. If `iot-agent` is not running, you can restart the containers as necessary."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Create a Service Group",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n \"services\": [\n   {\n     \"apikey\":      \"4jggokgpepnvsb2uv4s40d59ov\",\n     \"cbroker\":     \"http://orion:1026\",\n     \"entity_type\": \"Thing\",\n     \"resource\":    \"\"\n   }\n ]\n}"
						},
						"url": {
							"raw": "http://{{iot-agent}}/iot/services",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"services"
							]
						},
						"description": "Invoking group provision is always the the first step in connecting devices. For MQTT communication, provisioning supplies the authentication key so the IoT Agent will know which **topic** it must\nsubscribe to.\n\nIt is possible to set up default commands and attributes for all devices as well, but this\nis not done within this tutorial as we will be provisioning each device separately.\n\nThis example provisions an anonymous group of devices. It tells the IoT Agent that a series of devices\nwill be communicating by sending messages to the `/4jggokgpepnvsb2uv4s40d59ov` **topic**\n\nThe `resource` attribute is left blank since HTTP communication is not being used.\n\nThe URL location of  `cbroker` is an optional attribute - if it is not provided, the IoT\nAgent uses the default context broker URL as defined in the configuration file, however\nit has been added here for completeness."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Provision a Sensor",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n \"devices\": [\n   {\n     \"device_id\":   \"motion001\",\n     \"entity_name\": \"urn:ngsi-ld:Motion:001\",\n     \"entity_type\": \"Motion\",\n     \"protocol\":    \"PDI-IoTA-UltraLight\",\n     \"transport\":   \"MQTT\",\n     \"timezone\":    \"Europe/Berlin\",\n     \"attributes\": [\n       { \"object_id\": \"c\", \"name\":\"count\", \"type\":\"Integer\"}\n      ],\n      \"static_attributes\": [\n         {\"name\":\"refStore\", \"type\": \"Relationship\",\"value\": \"urn:ngsi-ld:Store:001\"}\n      ]\n   }\n ]\n}\n"
						},
						"url": {
							"raw": "http://{{iot-agent}}/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "It is common good practice to use URNs following the NGSI-LD [draft recommendation](https://docbox.etsi.org/ISG/CIM/Open/ISG_CIM_NGSI-LD_API_Draft_for_public_review.pdf) when creating entities. Furthermore it is easier to understand\nmeaningful names when defining data attributes. These mappings can be defined by provisioning a device individually.\n\nThree types of meaasurement attributes can be provisioned:\n\n* `attributes` are active readings from the device\n* `lazy` attributes are only sent on request -  The IoT Agent will inform the device to return the measurement\n* `static_attributes` are as the name suggests static data about the device (such as relationships) passed on \n  to the context broker.\n\n>**Note**: in the case where individual `id`s are not required, or aggregated data is sufficient \n> the `attributes` can be defined within the provisioning service rather than individually.\n\nIn the request we are assiociating the device `motion001` with the URN `urn:ngsd-ld:Motion:001`\nand mapping the device reading `c` with the context attribute `count` (which is defined as an `Integer`)\nA `refStore` is defined as a `static_attribute`, placing the device within **Store** `urn:ngsi-ld:Store:001`"
					},
					"response": []
				},
				{
					"name": "Context Broker - Read the Motion Sensor",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							}
						],
						"url": {
							"raw": "http://{{orion}}/v2/entities/urn:ngsi-ld:Motion:001",
							"protocol": "http",
							"host": [
								"{{orion}}"
							],
							"path": [
								"v2",
								"entities",
								"urn:ngsi-ld:Motion:001"
							]
						},
						"description": "To make a dummy measurement, send a topic to the **MQTT Broker** as shown.\n\n```\ndocker run -it --rm --name mqtt-publisher --network \\\n  fiware_default efrecon/mqtt-client pub -h mosquitto -m \"c|1\" -t \"/4jggokgpepnvsb2uv4s40d59ov/motion001/attrs\"\n```\n\n\nThen make the context data request.\n\nThis example returns the data for the `Motion` entity with the `id=urn:ngsd-ld:Motion:001` within the context data.\n\nThe response shows that the device with `id=motion001` has been successfully identifed by the IoT Agent and mapped to the\nentity `id=urn:ngsd-ld:Motion:001`. This new entity has been created within the context data. The `c` \nattribute from the dummy device measurement request has been mapped to the more meaningful `count` attribute\nwithin the context. As you will notice, a `TimeInstant` attribute has been added to both the entity and the\nmeta data of the attribute - this represents the last time the entity and attribute have been updated, and is\nautomatically added to each new entity because the `IOTA_TIMESTAMP`  environment variable was set when the\nIoT Agent was started up."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Provision an Actuator",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"devices\": [\n    {\n      \"device_id\": \"bell001\",\n      \"entity_name\": \"urn:ngsi-ld:Bell:001\",\n      \"entity_type\": \"Bell\",\n      \"protocol\": \"PDI-IoTA-UltraLight\",\n      \"apikey\":      \"4jggokgpepnvsb2uv4s40d59ov\",\n      \"transport\": \"MQTT\",\n      \"commands\": [ \n        {\n          \"name\": \"ring\",\n          \"type\": \"command\"\n        }\n       ],\n       \"static_attributes\": [\n         {\"name\":\"refStore\", \"type\": \"Relationship\",\"value\": \"urn:ngsi-ld:Store:001\"}\n    \t]\n    }\n  ]\n}\n"
						},
						"url": {
							"raw": "http://{{iot-agent}}/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "Provisioning an actuator is similar to provisioning a sensor. The `transport` attribute defines the communications\nprotocol to be used. For MQTT communications, the `endpoint` attribute  is not required as there is no HTTP url \nwhere the device is listening for commands.  The array of commands\nis mapped to directly to messages sent to the  `/<api-key>/<device-id>/cmd` **topic** \nThe `commands` array includes a list of each command that can be invoked. \n\nThe example below provisions a bell with the `deviceId=bell001`."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Invoke a Command",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"actionType\": \"update\",\n    \"entities\": [\n        {\n            \"type\": \"Bell\",\n            \"id\": \"urn:ngsi-ld:Bell:001\",\n            \"ring\" : {\n                \"type\": \"command\",\n                \"value\": \"\"\n            }\n        }\n    ]\n}"
						},
						"url": {
							"raw": "http://{{iot-agent}}/v2/op/update",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"v2",
								"op",
								"update"
							]
						},
						"description": "Before we wire-up the context broker, we can test that a command can be sent from the IoT Agent to a\ndevice by making a REST request directly to the IoT Agent's North Port using the `/v1/updateContext` endpoint.\nIt is this endpoint that will eventually be invoked by the context broker once we have connected it up.\nTo test the configuration you can run the command directly as shown.\n\nIf you are viewing the device monitor page, you can also see the state of the bell change.\n\n![](https://fiware.github.io/tutorials.IoT-Agent/img/bell-ring.gif)"
					},
					"response": []
				},
				{
					"name": "Context Broker - Read the Command Result",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							}
						],
						"url": {
							"raw": "http://{{orion}}/v2/entities/urn:ngsi-ld:Bell:001?options=keyValues",
							"protocol": "http",
							"host": [
								"{{orion}}"
							],
							"path": [
								"v2",
								"entities",
								"urn:ngsi-ld:Bell:001"
							],
							"query": [
								{
									"key": "options",
									"value": "keyValues"
								}
							]
						},
						"description": "The result of the command to ring the bell can be read by querying the entity within the Orion Context Broker. \n\nThe `TimeInstant` shows last the time any command associated with the entity has been invoked. the result of `ring` command can be see in the value of the `ring_info` attribute"
					},
					"response": []
				},
				{
					"name": "IoT Agent - Provision a Smart Door",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"devices\": [\n    {\n      \"device_id\": \"door001\",\n      \"entity_name\": \"urn:ngsi-ld:Door:001\",\n      \"entity_type\": \"Door\",\n      \"protocol\": \"PDI-IoTA-UltraLight\",\n      \"transport\": \"MQTT\",\n      \"commands\": [ \n        {\"name\": \"unlock\",\"type\": \"command\"},\n        {\"name\": \"open\",\"type\": \"command\"},\n        {\"name\": \"close\",\"type\": \"command\"},\n        {\"name\": \"lock\",\"type\": \"command\"}\n       ],\n       \"attributes\": [\n       \t{\"object_id\": \"s\", \"name\": \"state\", \"type\":\"Text\"}\n       ],\n       \"static_attributes\": [\n         {\"name\":\"refStore\", \"type\": \"Relationship\",\"value\": \"urn:ngsi-ld:Store:001\"}\n       ]\n    }\n  ]\n}\n"
						},
						"url": {
							"raw": "http://{{iot-agent}}/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "Provisioning  a device which offers both commands and measurements is merely a matter of \nmaking an HTTP POST request with both `attributes` and `command` attributes in the body of the \nrequest. Once again the `transport=MQTT` attribute defines the communications protocol to be used, \nand no `endpoint` attribute is required as there is no HTTP url where the device is listening \nfor commands."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Provision a Smart Lamp",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"devices\": [\n    {\n      \"device_id\": \"lamp001\",\n      \"entity_name\": \"urn:ngsi-ld:Lamp:001\",\n      \"entity_type\": \"Lamp\",\n      \"protocol\": \"PDI-IoTA-UltraLight\",\n      \"transport\": \"MQTT\",\n      \"commands\": [ \n        {\"name\": \"on\",\"type\": \"command\"},\n        {\"name\": \"off\",\"type\": \"command\"}\n       ],\n       \"attributes\": [\n       \t{\"object_id\": \"s\", \"name\": \"state\", \"type\":\"Text\"},\n        {\"object_id\": \"l\", \"name\": \"luminosity\", \"type\":\"Integer\"}\n       ],\n       \"static_attributes\": [\n         {\"name\":\"refStore\", \"type\": \"Relationship\",\"value\": \"urn:ngsi-ld:Store:001\"}\n    \t]\n    }\n  ]\n}\n"
						},
						"url": {
							"raw": "http://{{iot-agent}}/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "Provisioning  a device which offers both commands and measurements is merely a matter of making an HTTP POST request\nwith both `attributes` and `command` attributes in the body of the request.\n\nThis example provisions a smart door with two commands `on` and `off` and maps two attributes."
					},
					"response": []
				},
				{
					"name": "IoT Agent - List all Provisioned Devices",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							}
						],
						"url": {
							"raw": "http://{{iot-agent}}/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "This example lists all provisioned devices by making a GET request to the `/iot/devices` endpoint.\n\nThe response includes all the commands and attributes mappings associated with all provisioned IoT devices."
					},
					"response": []
				}
			],
			"description": "The IoT Agent acts as a middleware between the IoT devices and the context broker. It therefore\nneeds to be able to create context data entities with unique ids.  Once a service has been provisioned\nand an unknown device makes a measurement the IoT Agent add this to the context using the supplied\n`<device-id>` (unless the device is recognized and can be mapped to a known id.\n\nThere is no guarantee that every supplied IoT device `<device-id>` will always be unique, therefore \nall provisioning requests to the IoT Agent require two mandatory headers:\n\n* `fiware-service` header is defined so that entities for a given service can be held in a separate mongoDB database.\n* `fiware-servicepath` can be used to differenciate between arrays of devices. \n\nFor example within a smart city application you would expect different `fiware-service` headers for different\ndepartments (e.g. parks, transport, refuse collection etc.) and each `fiware-servicepath`  would refer to specific park \nand so on. This would mean that data and devices for each service can be identified and separated as needed, but the\ndata would not be siloed - for example data from a  **Smart Bin** within a park can be combined with the **GPS Unit** \nof a refuse truck to alter the route of the truck in an efficient manner. \n\nThe **Smart Bin** and **GPS Unit** are likely to come from different manufacturers and it cannot be \nguaranteed that that there is no overlap within `<device-ids>`s used. The use of the  `fiware-service` and\n`fiware-servicepath` headers can ensure that this is always the case, and allows the context broker to identify\nthe original source of the context data.\n",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Enabling Context Broker Commands",
			"item": [
				{
					"name": "Bell Commands",
					"item": [
						{
							"name": "Register Bell Commands",
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "fiware-service",
										"value": "openiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"description\": \"Bell Commands\",\n  \"dataProvided\": {\n    \"entities\": [\n      {\n        \"id\": \"urn:ngsi-ld:Bell:001\", \"type\": \"Bell\"\n      }\n    ],\n    \"attrs\": [\"ring\"]\n  },\n  \"provider\": {\n    \"http\": {\"url\": \"http://orion:1026/v1\"},\n    \"legacyForwarding\": true\n  }\n}"
								},
								"url": {
									"raw": "http://{{orion}}/v2/registrations?",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"registrations"
									],
									"query": [
										{
											"key": "type",
											"value": "Store",
											"description": "Entity type, to avoid ambiguity in case there are several entities with the same entity id",
											"disabled": true
										},
										{
											"key": "attrs",
											"value": "name",
											"description": "Ordered list of attribute names to display",
											"disabled": true
										}
									]
								},
								"description": "This example registers the `ring` command for the entity with the `id=\"urn:ngsi-ld:Bell:001\"`\n\nTo register the command we need to inform Orion that the URL `http://orion:1026/v1` is able to provide\nthe missing `ring` attribute. This will then be forwarded on to the IoT Agent. As you see this is an NGSI v1 \nendpoint and therefore the `legacyForwarding` attribute must also be set."
							},
							"response": []
						},
						{
							"name": "Ring Bell",
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "fiware-service",
										"value": "openiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n\t\"ring\": {\n    \t\"type\" : \"command\",\n    \t\"value\" : \"\"\n\t}\n}"
								},
								"url": {
									"raw": "http://{{orion}}/v2/entities/urn:ngsi-ld:Bell:001/attrs",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"entities",
										"urn:ngsi-ld:Bell:001",
										"attrs"
									]
								},
								"description": "To invoke the `ring` command, the `ring` attribute must be updated in the context.\n\nIf you are viewing the device monitor page, you can also see the state of the bell change.\n\n![](https://fiware.github.io/tutorials.IoT-Agent/img/bell-ring.gif)"
							},
							"response": []
						},
						{
							"name": "Bell Status",
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "fiware-service",
										"value": "openiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									}
								],
								"url": {
									"raw": "http://{{orion}}/v2/entities/urn:ngsi-ld:Bell:001?options=keyValues",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"entities",
										"urn:ngsi-ld:Bell:001"
									],
									"query": [
										{
											"key": "options",
											"value": "keyValues"
										}
									]
								},
								"description": "The result of the command to ring the bell can be read by querying the entity within the Orion Context Broker. \n\nThe `TimeInstant` shows last the time any command associated with the entity has been invoked. the result of `ring` command can be see in the value of the `ring_info` attribute"
							},
							"response": []
						}
					],
					"description": "The **Bell** entity has been mapped to `id=\"urn:ngsi-ld:Bell:001\"` with an entity `type=\"Bell\"`",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				},
				{
					"name": "Smart Door Commands",
					"item": [
						{
							"name": "Register Smart Door Commands",
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "fiware-service",
										"value": "openiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"description\": \"Door Commands\",\n  \"dataProvided\": {\n    \"entities\": [\n      {\n        \"id\": \"urn:ngsi-ld:Door:001\", \"type\": \"Door\"\n      }\n    ],\n    \"attrs\": [ \"lock\", \"unlock\", \"open\", \"close\"]\n  },\n  \"provider\": {\n    \"http\": {\"url\": \"http://orion:1026/v1\"},\n    \"legacyForwarding\": true\n  }\n}"
								},
								"url": {
									"raw": "http://{{orion}}/v2/registrations?",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"registrations"
									],
									"query": [
										{
											"key": "type",
											"value": "Store",
											"description": "Entity type, to avoid ambiguity in case there are several entities with the same entity id",
											"disabled": true
										},
										{
											"key": "attrs",
											"value": "name",
											"description": "Ordered list of attribute names to display",
											"disabled": true
										}
									]
								},
								"description": "This example registers the `lock`, `unlock`, `open` and `close` commands for the entity with\nthe `id=\"urn:ngsi-ld:Door:001\"`\n\nTo register the commands we need to inform Orion that the URL `http://orion:1026/v1` is able to provide\nthe missing  attributes. This will then be forwarded on to the IoT Agent. As you see this is an NGSI v1 \nendpoint and therefore the `legacyForwarding` attribute must also be set."
							},
							"response": []
						},
						{
							"name": "Open a Door",
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "fiware-service",
										"value": "openiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n\t\"open\": {\n    \t\"type\" : \"command\",\n    \t\"value\" : \"\"\n\t}\n}"
								},
								"url": {
									"raw": "http://{{orion}}/v2/entities/urn:ngsi-ld:Door:001/attrs",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"entities",
										"urn:ngsi-ld:Door:001",
										"attrs"
									]
								},
								"description": "To invoke the `open` command, the `open` attribute must be updated in the context."
							},
							"response": []
						},
						{
							"name": "Door Status",
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "fiware-service",
										"value": "openiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									}
								],
								"url": {
									"raw": "http://{{orion}}/v2/entities/urn:ngsi-ld:Door:001?options=keyValues",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"entities",
										"urn:ngsi-ld:Door:001"
									],
									"query": [
										{
											"key": "options",
											"value": "keyValues"
										}
									]
								},
								"description": "The result of the invocation of **Smart Door** commands can be read by querying the entity within the Orion Context Broker. \n\nThe `TimeInstant` shows last the time any command associated with the entity has been invoked. \n\n* The result of `open` command can be see in the value of the `open_info` attribute\n* The result of `close` command can be see in the value of the `close_info` attribute\n* The result of `lock` command can be see in the value of the `lock_info` attribute\n* The result of `unlock` command can be see in the value of the `unlock_info` attribute"
							},
							"response": []
						}
					],
					"description": "The **Smart Door** entity has been mapped to `id=\"urn:ngsi-ld:Door:001\"` with an entity `type=\"Door\"`",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				},
				{
					"name": "Smart Lamp",
					"item": [
						{
							"name": "Register Smart Lamp Commands",
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "fiware-service",
										"value": "openiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"description\": \"Lamp Commands\",\n  \"dataProvided\": {\n    \"entities\": [\n      {\n        \"id\": \"urn:ngsi-ld:Lamp:001\",\"type\": \"Lamp\"\n      }\n    ],\n    \"attrs\": [ \"on\", \"off\" ]\n  },\n  \"provider\": {\n    \"http\": {\"url\": \"http://orion:1026/v1\"},\n    \"legacyForwarding\": true\n  }\n}"
								},
								"url": {
									"raw": "http://{{orion}}/v2/registrations?",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"registrations"
									],
									"query": [
										{
											"key": "type",
											"value": "Store",
											"description": "Entity type, to avoid ambiguity in case there are several entities with the same entity id",
											"disabled": true
										},
										{
											"key": "attrs",
											"value": "name",
											"description": "Ordered list of attribute names to display",
											"disabled": true
										}
									]
								},
								"description": "This example registers the `on` and `off` commands for the entity with\nthe `id=\"urn:ngsi-ld:Lamp:001\"`\n\nTo register the commands we need to inform Orion that the URL `http://orion:1026/v1` is able to provide\nthe missing  attributes. This will then be forwarded on to the IoT Agent. As you see this is an NGSI v1 \nendpoint and therefore the `legacyForwarding` attribute must also be set."
							},
							"response": []
						},
						{
							"name": "Switch On a Lamp",
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "fiware-service",
										"value": "openiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n\t\"on\": {\n    \t\"type\" : \"command\",\n    \t\"value\" : \"\"\n\t}\n}"
								},
								"url": {
									"raw": "http://{{orion}}/v2/entities/urn:ngsi-ld:Lamp:001/attrs",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"entities",
										"urn:ngsi-ld:Lamp:001",
										"attrs"
									]
								},
								"description": "To switch on the **Smart Lamp**, the `on` attribute must be updated in the context."
							},
							"response": []
						},
						{
							"name": "Lamp Status",
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "fiware-service",
										"value": "openiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									}
								],
								"url": {
									"raw": "http://{{orion}}/v2/entities/urn:ngsi-ld:Lamp:001?options=keyValues",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"entities",
										"urn:ngsi-ld:Lamp:001"
									],
									"query": [
										{
											"key": "options",
											"value": "keyValues"
										}
									]
								},
								"description": "The result of the invocation of **Smart Lamp** commands can be read by querying the entity within the Orion Context Broker. \n\nThe `TimeInstant` shows last the time any command associated with the entity has been invoked. \n\n* The result of `on` command can be see in the value of the `on_info` attribute\n* The result of `off` command can be see in the value of the `off_info` attribute"
							},
							"response": []
						}
					],
					"description": "The **Smart Lamp** entity has been mapped to `id=\"urn:ngsi-ld:Lamp:001\"` with an entity `type=\"Lamp\"`",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				},
				{
					"name": "List Provisioned Devices",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							}
						],
						"url": {
							"raw": "http://{{orion}}/v2/entities/",
							"protocol": "http",
							"host": [
								"{{orion}}"
							],
							"path": [
								"v2",
								"entities",
								""
							]
						},
						"description": "This example returns the data of all `Store` entities within the context data"
					},
					"response": []
				}
			],
			"description": "Having connected up the IoT Agent to the IoT devices, we now need to inform the Orion Context Broker that the commands\nare available. In other words we need to register the IoT Agent as a [Context Provider](https://github.com/Fiware/tutorials.Context-Providers/) for the command attributes.\n\nOnce the commands have been registered it will be possible to ring the **Bell**, open and close the **Smart Door** and\nswitch the **Smart Lamp** on and off by sending requests to the Orion Context Broker, rather than sending UltraLight 2.0\nrequests directly t the IoT devices as we did in the [previous tutorial](https://github.com/Fiware/tutorials.IoT-Sensors)",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "iot-agent",
			"value": "localhost:4041"
		},
		{
			"key": "orion",
			"value": "localhost:1026"
		},
		{
			"key": "ultralight",
			"value": "localhost:3001"
		}
	]
}